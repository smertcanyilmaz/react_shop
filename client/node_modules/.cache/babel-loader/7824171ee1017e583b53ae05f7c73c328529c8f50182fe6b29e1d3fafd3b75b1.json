{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RequestSender = void 0;\nvar Error_js_1 = require(\"./Error.js\");\nvar utils_js_1 = require(\"./utils.js\");\nvar HttpClient_js_1 = require(\"./net/HttpClient.js\");\nvar MAX_RETRY_AFTER_WAIT = 60;\nvar RequestSender = /*#__PURE__*/function () {\n  function RequestSender(stripe, maxBufferedRequestMetric) {\n    _classCallCheck(this, RequestSender);\n    this._stripe = stripe;\n    this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n  }\n  _createClass(RequestSender, [{\n    key: \"_addHeadersDirectlyToObject\",\n    value: function _addHeadersDirectlyToObject(obj, headers) {\n      // For convenience, make some headers easily accessible on\n      // lastResponse.\n      // NOTE: Stripe responds with lowercase header names/keys.\n      obj.requestId = headers['request-id'];\n      obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n      obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n      obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n    }\n  }, {\n    key: \"_makeResponseEvent\",\n    value: function _makeResponseEvent(requestEvent, statusCode, headers) {\n      var requestEndTime = Date.now();\n      var requestDurationMs = requestEndTime - requestEvent.request_start_time;\n      return (0, utils_js_1.removeNullish)({\n        api_version: headers['stripe-version'],\n        account: headers['stripe-account'],\n        idempotency_key: headers['idempotency-key'],\n        method: requestEvent.method,\n        path: requestEvent.path,\n        status: statusCode,\n        request_id: this._getRequestId(headers),\n        elapsed: requestDurationMs,\n        request_start_time: requestEvent.request_start_time,\n        request_end_time: requestEndTime\n      });\n    }\n  }, {\n    key: \"_getRequestId\",\n    value: function _getRequestId(headers) {\n      return headers['request-id'];\n    }\n    /**\n     * Used by methods with spec.streaming === true. For these methods, we do not\n     * buffer successful responses into memory or do parse them into stripe\n     * objects, we delegate that all of that to the user and pass back the raw\n     * http.Response object to the callback.\n     *\n     * (Unsuccessful responses shouldn't make it here, they should\n     * still be buffered/parsed and handled by _jsonResponseHandler -- see\n     * makeRequest)\n     */\n  }, {\n    key: \"_streamingResponseHandler\",\n    value: function _streamingResponseHandler(requestEvent, callback) {\n      var _this = this;\n      return function (res) {\n        var headers = res.getHeaders();\n        var streamCompleteCallback = function streamCompleteCallback() {\n          var responseEvent = _this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n          _this._stripe._emitter.emit('response', responseEvent);\n          _this._recordRequestMetrics(_this._getRequestId(headers), responseEvent.elapsed);\n        };\n        var stream = res.toStream(streamCompleteCallback);\n        // This is here for backwards compatibility, as the stream is a raw\n        // HTTP response in Node and the legacy behavior was to mutate this\n        // response.\n        _this._addHeadersDirectlyToObject(stream, headers);\n        return callback(null, stream);\n      };\n    }\n    /**\n     * Default handler for Stripe responses. Buffers the response into memory,\n     * parses the JSON and returns it (i.e. passes it to the callback) if there\n     * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n     */\n  }, {\n    key: \"_jsonResponseHandler\",\n    value: function _jsonResponseHandler(requestEvent, callback) {\n      var _this2 = this;\n      return function (res) {\n        var headers = res.getHeaders();\n        var requestId = _this2._getRequestId(headers);\n        var statusCode = res.getStatusCode();\n        var responseEvent = _this2._makeResponseEvent(requestEvent, statusCode, headers);\n        _this2._stripe._emitter.emit('response', responseEvent);\n        res.toJSON().then(function (jsonResponse) {\n          if (jsonResponse.error) {\n            var err;\n            // Convert OAuth error responses into a standard format\n            // so that the rest of the error logic can be shared\n            if (typeof jsonResponse.error === 'string') {\n              jsonResponse.error = {\n                type: jsonResponse.error,\n                message: jsonResponse.error_description\n              };\n            }\n            jsonResponse.error.headers = headers;\n            jsonResponse.error.statusCode = statusCode;\n            jsonResponse.error.requestId = requestId;\n            if (statusCode === 401) {\n              err = new Error_js_1.StripeAuthenticationError(jsonResponse.error);\n            } else if (statusCode === 403) {\n              err = new Error_js_1.StripePermissionError(jsonResponse.error);\n            } else if (statusCode === 429) {\n              err = new Error_js_1.StripeRateLimitError(jsonResponse.error);\n            } else {\n              err = Error_js_1.StripeError.generate(jsonResponse.error);\n            }\n            throw err;\n          }\n          return jsonResponse;\n        }, function (e) {\n          throw new Error_js_1.StripeAPIError({\n            message: 'Invalid JSON received from the Stripe API',\n            exception: e,\n            requestId: headers['request-id']\n          });\n        }).then(function (jsonResponse) {\n          _this2._recordRequestMetrics(requestId, responseEvent.elapsed);\n          // Expose raw response object.\n          var rawResponse = res.getRawResponse();\n          _this2._addHeadersDirectlyToObject(rawResponse, headers);\n          Object.defineProperty(jsonResponse, 'lastResponse', {\n            enumerable: false,\n            writable: false,\n            value: rawResponse\n          });\n          callback(null, jsonResponse);\n        }, function (e) {\n          return callback(e, null);\n        });\n      };\n    }\n  }, {\n    key: \"_getSleepTimeInMS\",\n    value: function _getSleepTimeInMS(numRetries) {\n      var retryAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n      var maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n      // Apply exponential backoff with initialNetworkRetryDelay on the\n      // number of numRetries so far as inputs. Do not allow the number to exceed\n      // maxNetworkRetryDelay.\n      var sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n      // Apply some jitter by randomizing the value in the range of\n      // (sleepSeconds / 2) to (sleepSeconds).\n      sleepSeconds *= 0.5 * (1 + Math.random());\n      // But never sleep less than the base sleep seconds.\n      sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n      // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n      if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n        sleepSeconds = Math.max(sleepSeconds, retryAfter);\n      }\n      return sleepSeconds * 1000;\n    }\n    // Max retries can be set on a per request basis. Favor those over the global setting\n  }, {\n    key: \"_getMaxNetworkRetries\",\n    value: function _getMaxNetworkRetries() {\n      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return settings.maxNetworkRetries !== undefined && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n    }\n  }, {\n    key: \"_defaultIdempotencyKey\",\n    value: function _defaultIdempotencyKey(method, settings) {\n      // If this is a POST and we allow multiple retries, ensure an idempotency key.\n      var maxRetries = this._getMaxNetworkRetries(settings);\n      if (method === 'POST' && maxRetries > 0) {\n        return \"stripe-node-retry-\".concat(this._stripe._platformFunctions.uuid4());\n      }\n      return null;\n    }\n  }, {\n    key: \"_makeHeaders\",\n    value: function _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n      var defaultHeaders = {\n        // Use specified auth token or use default from this stripe instance:\n        Authorization: auth ? \"Bearer \".concat(auth) : this._stripe.getApiField('auth'),\n        Accept: 'application/json',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'User-Agent': this._getUserAgentString(),\n        'X-Stripe-Client-User-Agent': clientUserAgent,\n        'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n        'Stripe-Version': apiVersion,\n        'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n        'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)\n      };\n      // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n      //   A user agent SHOULD send a Content-Length in a request message when\n      //   no Transfer-Encoding is sent and the request method defines a meaning\n      //   for an enclosed payload body.  For example, a Content-Length header\n      //   field is normally sent in a POST request even when the value is 0\n      //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n      //   Content-Length header field when the request message does not contain\n      //   a payload body and the method semantics do not anticipate such a\n      //   body.\n      //\n      // These method types are expected to have bodies and so we should always\n      // include a Content-Length.\n      var methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n      // If a content length was specified, we always include it regardless of\n      // whether the method semantics anticipate such a body. This keeps us\n      // consistent with historical behavior. We do however want to warn on this\n      // and fix these cases as they are semantically incorrect.\n      if (methodHasPayload || contentLength) {\n        if (!methodHasPayload) {\n          (0, utils_js_1.emitWarning)(\"\".concat(method, \" method had non-zero contentLength but no payload is expected for this verb\"));\n        }\n        defaultHeaders['Content-Length'] = contentLength;\n      }\n      return Object.assign((0, utils_js_1.removeNullish)(defaultHeaders),\n      // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n      (0, utils_js_1.normalizeHeaders)(userSuppliedHeaders));\n    }\n  }, {\n    key: \"_getUserAgentString\",\n    value: function _getUserAgentString() {\n      var packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n      var appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n      return \"Stripe/v1 NodeBindings/\".concat(packageVersion, \" \").concat(appInfo).trim();\n    }\n  }, {\n    key: \"_getTelemetryHeader\",\n    value: function _getTelemetryHeader() {\n      if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n        var metrics = this._stripe._prevRequestMetrics.shift();\n        return JSON.stringify({\n          last_request_metrics: metrics\n        });\n      }\n    }\n  }, {\n    key: \"_recordRequestMetrics\",\n    value: function _recordRequestMetrics(requestId, requestDurationMs) {\n      if (this._stripe.getTelemetryEnabled() && requestId) {\n        if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n          (0, utils_js_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');\n        } else {\n          this._stripe._prevRequestMetrics.push({\n            request_id: requestId,\n            request_duration_ms: requestDurationMs\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_request\",\n    value: function _request(method, host, path, data, auth) {\n      var _this3 = this;\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n      var callback = arguments.length > 6 ? arguments[6] : undefined;\n      var requestDataProcessor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n      var requestData;\n      var retryRequest = function retryRequest(requestFn, apiVersion, headers, requestRetries, retryAfter) {\n        return setTimeout(requestFn, _this3._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n      };\n      var makeRequest = function makeRequest(apiVersion, headers, numRetries) {\n        // timeout can be set on a per-request basis. Favor that over the global setting\n        var timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : _this3._stripe.getApiField('timeout');\n        var req = _this3._stripe.getApiField('httpClient').makeRequest(host || _this3._stripe.getApiField('host'), _this3._stripe.getApiField('port'), path, method, headers, requestData, _this3._stripe.getApiField('protocol'), timeout);\n        var requestStartTime = Date.now();\n        // @ts-ignore\n        var requestEvent = (0, utils_js_1.removeNullish)({\n          api_version: apiVersion,\n          account: headers['Stripe-Account'],\n          idempotency_key: headers['Idempotency-Key'],\n          method: method,\n          path: path,\n          request_start_time: requestStartTime\n        });\n        var requestRetries = numRetries || 0;\n        var maxRetries = _this3._getMaxNetworkRetries(options.settings || {});\n        _this3._stripe._emitter.emit('request', requestEvent);\n        req.then(function (res) {\n          if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n            return retryRequest(makeRequest, apiVersion, headers, requestRetries,\n            // @ts-ignore\n            res.getHeaders()['retry-after']);\n          } else if (options.streaming && res.getStatusCode() < 400) {\n            return _this3._streamingResponseHandler(requestEvent, callback)(res);\n          } else {\n            return _this3._jsonResponseHandler(requestEvent, callback)(res);\n          }\n        }).catch(function (error) {\n          if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n            return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n          } else {\n            var isTimeoutError = error.code && error.code === HttpClient_js_1.HttpClient.TIMEOUT_ERROR_CODE;\n            return callback(new Error_js_1.StripeConnectionError({\n              message: isTimeoutError ? \"Request aborted due to timeout being reached (\".concat(timeout, \"ms)\") : RequestSender._generateConnectionErrorMessage(requestRetries),\n              // @ts-ignore\n              detail: error\n            }));\n          }\n        });\n      };\n      var prepareAndMakeRequest = function prepareAndMakeRequest(error, data) {\n        if (error) {\n          return callback(error);\n        }\n        requestData = data;\n        _this3._stripe.getClientUserAgent(function (clientUserAgent) {\n          var _a, _b;\n          var apiVersion = _this3._stripe.getApiField('version');\n          var headers = _this3._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n          makeRequest(apiVersion, headers, 0);\n        });\n      };\n      if (requestDataProcessor) {\n        requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n      } else {\n        prepareAndMakeRequest(null, (0, utils_js_1.stringifyRequestData)(data || {}));\n      }\n    }\n  }], [{\n    key: \"_generateConnectionErrorMessage\",\n    value: function _generateConnectionErrorMessage(requestRetries) {\n      return \"An error occurred with our connection to Stripe.\".concat(requestRetries > 0 ? \" Request was retried \".concat(requestRetries, \" times.\") : '');\n    }\n    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  }, {\n    key: \"_shouldRetry\",\n    value: function _shouldRetry(res, numRetries, maxRetries, error) {\n      if (error && numRetries === 0 && HttpClient_js_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n        return true;\n      }\n      // Do not retry if we are out of retries.\n      if (numRetries >= maxRetries) {\n        return false;\n      }\n      // Retry on connection error.\n      if (!res) {\n        return true;\n      }\n      // The API may ask us not to retry (e.g., if doing so would be a no-op)\n      // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n      if (res.getHeaders()['stripe-should-retry'] === 'false') {\n        return false;\n      }\n      if (res.getHeaders()['stripe-should-retry'] === 'true') {\n        return true;\n      }\n      // Retry on conflict errors.\n      if (res.getStatusCode() === 409) {\n        return true;\n      }\n      // Retry on 500, 503, and other internal errors.\n      //\n      // Note that we expect the stripe-should-retry header to be false\n      // in most cases when a 500 is returned, since our idempotency framework\n      // would typically replay it anyway.\n      if (res.getStatusCode() >= 500) {\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return RequestSender;\n}();\nexports.RequestSender = RequestSender;","map":{"version":3,"names":["_classCallCheck","require","default","_createClass","Object","defineProperty","exports","value","RequestSender","Error_js_1","utils_js_1","HttpClient_js_1","MAX_RETRY_AFTER_WAIT","stripe","maxBufferedRequestMetric","_stripe","_maxBufferedRequestMetric","key","_addHeadersDirectlyToObject","obj","headers","requestId","stripeAccount","apiVersion","idempotencyKey","_makeResponseEvent","requestEvent","statusCode","requestEndTime","Date","now","requestDurationMs","request_start_time","removeNullish","api_version","account","idempotency_key","method","path","status","request_id","_getRequestId","elapsed","request_end_time","_streamingResponseHandler","callback","_this","res","getHeaders","streamCompleteCallback","responseEvent","getStatusCode","_emitter","emit","_recordRequestMetrics","stream","toStream","_jsonResponseHandler","_this2","toJSON","then","jsonResponse","error","err","type","message","error_description","StripeAuthenticationError","StripePermissionError","StripeRateLimitError","StripeError","generate","e","StripeAPIError","exception","rawResponse","getRawResponse","enumerable","writable","_getSleepTimeInMS","numRetries","retryAfter","arguments","length","undefined","initialNetworkRetryDelay","getInitialNetworkRetryDelay","maxNetworkRetryDelay","getMaxNetworkRetryDelay","sleepSeconds","Math","min","pow","random","max","Number","isInteger","_getMaxNetworkRetries","settings","maxNetworkRetries","getMaxNetworkRetries","_defaultIdempotencyKey","maxRetries","concat","_platformFunctions","uuid4","_makeHeaders","auth","contentLength","clientUserAgent","userSuppliedHeaders","userSuppliedSettings","defaultHeaders","Authorization","getApiField","Accept","_getUserAgentString","_getTelemetryHeader","methodHasPayload","emitWarning","assign","normalizeHeaders","packageVersion","getConstant","appInfo","_appInfo","getAppInfoAsString","trim","getTelemetryEnabled","_prevRequestMetrics","metrics","shift","JSON","stringify","last_request_metrics","push","request_duration_ms","_request","host","data","_this3","options","requestDataProcessor","requestData","retryRequest","requestFn","requestRetries","setTimeout","makeRequest","timeout","req","requestStartTime","_shouldRetry","streaming","catch","isTimeoutError","code","HttpClient","TIMEOUT_ERROR_CODE","StripeConnectionError","_generateConnectionErrorMessage","detail","prepareAndMakeRequest","getClientUserAgent","_a","_b","stringifyRequestData","CONNECTION_CLOSED_ERROR_CODES","includes"],"sources":["C:/Users/Smert/OneDrive/Masaüstü/react_shop/client/node_modules/stripe/cjs/RequestSender.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RequestSender = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst HttpClient_js_1 = require(\"./net/HttpClient.js\");\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n    constructor(stripe, maxBufferedRequestMetric) {\n        this._stripe = stripe;\n        this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n    }\n    _addHeadersDirectlyToObject(obj, headers) {\n        // For convenience, make some headers easily accessible on\n        // lastResponse.\n        // NOTE: Stripe responds with lowercase header names/keys.\n        obj.requestId = headers['request-id'];\n        obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n        obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n        obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n    }\n    _makeResponseEvent(requestEvent, statusCode, headers) {\n        const requestEndTime = Date.now();\n        const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n        return (0, utils_js_1.removeNullish)({\n            api_version: headers['stripe-version'],\n            account: headers['stripe-account'],\n            idempotency_key: headers['idempotency-key'],\n            method: requestEvent.method,\n            path: requestEvent.path,\n            status: statusCode,\n            request_id: this._getRequestId(headers),\n            elapsed: requestDurationMs,\n            request_start_time: requestEvent.request_start_time,\n            request_end_time: requestEndTime,\n        });\n    }\n    _getRequestId(headers) {\n        return headers['request-id'];\n    }\n    /**\n     * Used by methods with spec.streaming === true. For these methods, we do not\n     * buffer successful responses into memory or do parse them into stripe\n     * objects, we delegate that all of that to the user and pass back the raw\n     * http.Response object to the callback.\n     *\n     * (Unsuccessful responses shouldn't make it here, they should\n     * still be buffered/parsed and handled by _jsonResponseHandler -- see\n     * makeRequest)\n     */\n    _streamingResponseHandler(requestEvent, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const streamCompleteCallback = () => {\n                const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n                this._stripe._emitter.emit('response', responseEvent);\n                this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed);\n            };\n            const stream = res.toStream(streamCompleteCallback);\n            // This is here for backwards compatibility, as the stream is a raw\n            // HTTP response in Node and the legacy behavior was to mutate this\n            // response.\n            this._addHeadersDirectlyToObject(stream, headers);\n            return callback(null, stream);\n        };\n    }\n    /**\n     * Default handler for Stripe responses. Buffers the response into memory,\n     * parses the JSON and returns it (i.e. passes it to the callback) if there\n     * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n     */\n    _jsonResponseHandler(requestEvent, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const requestId = this._getRequestId(headers);\n            const statusCode = res.getStatusCode();\n            const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n            this._stripe._emitter.emit('response', responseEvent);\n            res\n                .toJSON()\n                .then((jsonResponse) => {\n                if (jsonResponse.error) {\n                    let err;\n                    // Convert OAuth error responses into a standard format\n                    // so that the rest of the error logic can be shared\n                    if (typeof jsonResponse.error === 'string') {\n                        jsonResponse.error = {\n                            type: jsonResponse.error,\n                            message: jsonResponse.error_description,\n                        };\n                    }\n                    jsonResponse.error.headers = headers;\n                    jsonResponse.error.statusCode = statusCode;\n                    jsonResponse.error.requestId = requestId;\n                    if (statusCode === 401) {\n                        err = new Error_js_1.StripeAuthenticationError(jsonResponse.error);\n                    }\n                    else if (statusCode === 403) {\n                        err = new Error_js_1.StripePermissionError(jsonResponse.error);\n                    }\n                    else if (statusCode === 429) {\n                        err = new Error_js_1.StripeRateLimitError(jsonResponse.error);\n                    }\n                    else {\n                        err = Error_js_1.StripeError.generate(jsonResponse.error);\n                    }\n                    throw err;\n                }\n                return jsonResponse;\n            }, (e) => {\n                throw new Error_js_1.StripeAPIError({\n                    message: 'Invalid JSON received from the Stripe API',\n                    exception: e,\n                    requestId: headers['request-id'],\n                });\n            })\n                .then((jsonResponse) => {\n                this._recordRequestMetrics(requestId, responseEvent.elapsed);\n                // Expose raw response object.\n                const rawResponse = res.getRawResponse();\n                this._addHeadersDirectlyToObject(rawResponse, headers);\n                Object.defineProperty(jsonResponse, 'lastResponse', {\n                    enumerable: false,\n                    writable: false,\n                    value: rawResponse,\n                });\n                callback(null, jsonResponse);\n            }, (e) => callback(e, null));\n        };\n    }\n    static _generateConnectionErrorMessage(requestRetries) {\n        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n    }\n    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n    static _shouldRetry(res, numRetries, maxRetries, error) {\n        if (error &&\n            numRetries === 0 &&\n            HttpClient_js_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n            return true;\n        }\n        // Do not retry if we are out of retries.\n        if (numRetries >= maxRetries) {\n            return false;\n        }\n        // Retry on connection error.\n        if (!res) {\n            return true;\n        }\n        // The API may ask us not to retry (e.g., if doing so would be a no-op)\n        // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n        if (res.getHeaders()['stripe-should-retry'] === 'false') {\n            return false;\n        }\n        if (res.getHeaders()['stripe-should-retry'] === 'true') {\n            return true;\n        }\n        // Retry on conflict errors.\n        if (res.getStatusCode() === 409) {\n            return true;\n        }\n        // Retry on 500, 503, and other internal errors.\n        //\n        // Note that we expect the stripe-should-retry header to be false\n        // in most cases when a 500 is returned, since our idempotency framework\n        // would typically replay it anyway.\n        if (res.getStatusCode() >= 500) {\n            return true;\n        }\n        return false;\n    }\n    _getSleepTimeInMS(numRetries, retryAfter = null) {\n        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n        // Apply exponential backoff with initialNetworkRetryDelay on the\n        // number of numRetries so far as inputs. Do not allow the number to exceed\n        // maxNetworkRetryDelay.\n        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n        // Apply some jitter by randomizing the value in the range of\n        // (sleepSeconds / 2) to (sleepSeconds).\n        sleepSeconds *= 0.5 * (1 + Math.random());\n        // But never sleep less than the base sleep seconds.\n        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n        // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n            sleepSeconds = Math.max(sleepSeconds, retryAfter);\n        }\n        return sleepSeconds * 1000;\n    }\n    // Max retries can be set on a per request basis. Favor those over the global setting\n    _getMaxNetworkRetries(settings = {}) {\n        return settings.maxNetworkRetries !== undefined &&\n            Number.isInteger(settings.maxNetworkRetries)\n            ? settings.maxNetworkRetries\n            : this._stripe.getMaxNetworkRetries();\n    }\n    _defaultIdempotencyKey(method, settings) {\n        // If this is a POST and we allow multiple retries, ensure an idempotency key.\n        const maxRetries = this._getMaxNetworkRetries(settings);\n        if (method === 'POST' && maxRetries > 0) {\n            return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n        }\n        return null;\n    }\n    _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n        const defaultHeaders = {\n            // Use specified auth token or use default from this stripe instance:\n            Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n            Accept: 'application/json',\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'User-Agent': this._getUserAgentString(),\n            'X-Stripe-Client-User-Agent': clientUserAgent,\n            'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n            'Stripe-Version': apiVersion,\n            'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n            'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings),\n        };\n        // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n        //   A user agent SHOULD send a Content-Length in a request message when\n        //   no Transfer-Encoding is sent and the request method defines a meaning\n        //   for an enclosed payload body.  For example, a Content-Length header\n        //   field is normally sent in a POST request even when the value is 0\n        //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n        //   Content-Length header field when the request message does not contain\n        //   a payload body and the method semantics do not anticipate such a\n        //   body.\n        //\n        // These method types are expected to have bodies and so we should always\n        // include a Content-Length.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        // If a content length was specified, we always include it regardless of\n        // whether the method semantics anticipate such a body. This keeps us\n        // consistent with historical behavior. We do however want to warn on this\n        // and fix these cases as they are semantically incorrect.\n        if (methodHasPayload || contentLength) {\n            if (!methodHasPayload) {\n                (0, utils_js_1.emitWarning)(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n            }\n            defaultHeaders['Content-Length'] = contentLength;\n        }\n        return Object.assign((0, utils_js_1.removeNullish)(defaultHeaders), \n        // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n        (0, utils_js_1.normalizeHeaders)(userSuppliedHeaders));\n    }\n    _getUserAgentString() {\n        const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n        const appInfo = this._stripe._appInfo\n            ? this._stripe.getAppInfoAsString()\n            : '';\n        return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n    }\n    _getTelemetryHeader() {\n        if (this._stripe.getTelemetryEnabled() &&\n            this._stripe._prevRequestMetrics.length > 0) {\n            const metrics = this._stripe._prevRequestMetrics.shift();\n            return JSON.stringify({\n                last_request_metrics: metrics,\n            });\n        }\n    }\n    _recordRequestMetrics(requestId, requestDurationMs) {\n        if (this._stripe.getTelemetryEnabled() && requestId) {\n            if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n                (0, utils_js_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');\n            }\n            else {\n                this._stripe._prevRequestMetrics.push({\n                    request_id: requestId,\n                    request_duration_ms: requestDurationMs,\n                });\n            }\n        }\n    }\n    _request(method, host, path, data, auth, options = {}, callback, requestDataProcessor = null) {\n        let requestData;\n        const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n            return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n        };\n        const makeRequest = (apiVersion, headers, numRetries) => {\n            // timeout can be set on a per-request basis. Favor that over the global setting\n            const timeout = options.settings &&\n                options.settings.timeout &&\n                Number.isInteger(options.settings.timeout) &&\n                options.settings.timeout >= 0\n                ? options.settings.timeout\n                : this._stripe.getApiField('timeout');\n            const req = this._stripe\n                .getApiField('httpClient')\n                .makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n            const requestStartTime = Date.now();\n            // @ts-ignore\n            const requestEvent = (0, utils_js_1.removeNullish)({\n                api_version: apiVersion,\n                account: headers['Stripe-Account'],\n                idempotency_key: headers['Idempotency-Key'],\n                method,\n                path,\n                request_start_time: requestStartTime,\n            });\n            const requestRetries = numRetries || 0;\n            const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n            this._stripe._emitter.emit('request', requestEvent);\n            req\n                .then((res) => {\n                if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, \n                    // @ts-ignore\n                    res.getHeaders()['retry-after']);\n                }\n                else if (options.streaming && res.getStatusCode() < 400) {\n                    return this._streamingResponseHandler(requestEvent, callback)(res);\n                }\n                else {\n                    return this._jsonResponseHandler(requestEvent, callback)(res);\n                }\n            })\n                .catch((error) => {\n                if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n                }\n                else {\n                    const isTimeoutError = error.code && error.code === HttpClient_js_1.HttpClient.TIMEOUT_ERROR_CODE;\n                    return callback(new Error_js_1.StripeConnectionError({\n                        message: isTimeoutError\n                            ? `Request aborted due to timeout being reached (${timeout}ms)`\n                            : RequestSender._generateConnectionErrorMessage(requestRetries),\n                        // @ts-ignore\n                        detail: error,\n                    }));\n                }\n            });\n        };\n        const prepareAndMakeRequest = (error, data) => {\n            if (error) {\n                return callback(error);\n            }\n            requestData = data;\n            this._stripe.getClientUserAgent((clientUserAgent) => {\n                var _a, _b;\n                const apiVersion = this._stripe.getApiField('version');\n                const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n                makeRequest(apiVersion, headers, 0);\n            });\n        };\n        if (requestDataProcessor) {\n            requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n        }\n        else {\n            prepareAndMakeRequest(null, (0, utils_js_1.stringifyRequestData)(data || {}));\n        }\n    }\n}\nexports.RequestSender = RequestSender;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}