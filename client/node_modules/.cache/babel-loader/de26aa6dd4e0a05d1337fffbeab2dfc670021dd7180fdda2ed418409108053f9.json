{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchHttpClientResponse = exports.FetchHttpClient = void 0;\nvar HttpClient_js_1 = require(\"./HttpClient.js\");\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nvar FetchHttpClient = /*#__PURE__*/function (_HttpClient_js_1$Http) {\n  _inherits(FetchHttpClient, _HttpClient_js_1$Http);\n  var _super = _createSuper(FetchHttpClient);\n  function FetchHttpClient(fetchFn) {\n    var _this;\n    _classCallCheck(this, FetchHttpClient);\n    _this = _super.call(this);\n    _this._fetchFn = fetchFn;\n    return _this;\n  }\n  /** @override. */\n  _createClass(FetchHttpClient, [{\n    key: \"getClientName\",\n    value: function getClientName() {\n      return 'fetch';\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n      var isInsecureConnection = protocol === 'http';\n      var url = new URL(path, \"\".concat(isInsecureConnection ? 'http' : 'https', \"://\").concat(host));\n      url.port = port;\n      // For methods which expect payloads, we should always pass a body value\n      // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n      // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n      // for more details.\n      var methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n      var body = requestData || (methodHasPayload ? '' : undefined);\n      var fetchFn = this._fetchFn || fetch;\n      var fetchPromise = fetchFn(url.toString(), {\n        method: method,\n        // @ts-ignore\n        headers: headers,\n        // @ts-ignore\n        body: body\n      });\n      // The Fetch API does not support passing in a timeout natively, so a\n      // timeout promise is constructed to race against the fetch and preempt the\n      // request, simulating a timeout.\n      //\n      // This timeout behavior differs from Node:\n      // - Fetch uses a single timeout for the entire length of the request.\n      // - Node is more fine-grained and resets the timeout after each stage of\n      //   the request.\n      //\n      // As an example, if the timeout is set to 30s and the connection takes 20s\n      // to be established followed by 20s for the body, Fetch would timeout but\n      // Node would not. The more fine-grained timeout cannot be implemented with\n      // fetch.\n      var pendingTimeoutId;\n      var timeoutPromise = new Promise(function (_, reject) {\n        pendingTimeoutId = setTimeout(function () {\n          pendingTimeoutId = null;\n          reject(HttpClient_js_1.HttpClient.makeTimeoutError());\n        }, timeout);\n      });\n      return Promise.race([fetchPromise, timeoutPromise]).then(function (res) {\n        return new FetchHttpClientResponse(res);\n      }).finally(function () {\n        if (pendingTimeoutId) {\n          clearTimeout(pendingTimeoutId);\n        }\n      });\n    }\n  }]);\n  return FetchHttpClient;\n}(HttpClient_js_1.HttpClient);\nexports.FetchHttpClient = FetchHttpClient;\nvar FetchHttpClientResponse = /*#__PURE__*/function (_HttpClient_js_1$Http2) {\n  _inherits(FetchHttpClientResponse, _HttpClient_js_1$Http2);\n  var _super2 = _createSuper(FetchHttpClientResponse);\n  function FetchHttpClientResponse(res) {\n    var _this2;\n    _classCallCheck(this, FetchHttpClientResponse);\n    _this2 = _super2.call(this, res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n    _this2._res = res;\n    return _this2;\n  }\n  _createClass(FetchHttpClientResponse, [{\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this._res;\n    }\n  }, {\n    key: \"toStream\",\n    value: function toStream(streamCompleteCallback) {\n      // Unfortunately `fetch` does not have event handlers for when the stream is\n      // completely read. We therefore invoke the streamCompleteCallback right\n      // away. This callback emits a response event with metadata and completes\n      // metrics, so it's ok to do this without waiting for the stream to be\n      // completely read.\n      streamCompleteCallback();\n      // Fetch's `body` property is expected to be a readable stream of the body.\n      return this._res.body;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._res.json();\n    }\n  }], [{\n    key: \"_transformHeadersToObject\",\n    value: function _transformHeadersToObject(headers) {\n      // Fetch uses a Headers instance so this must be converted to a barebones\n      // JS object to meet the HttpClient interface.\n      var headersObj = {};\n      var _iterator = _createForOfIteratorHelper(headers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          if (!Array.isArray(entry) || entry.length != 2) {\n            throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n          }\n          headersObj[entry[0]] = entry[1];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return headersObj;\n    }\n  }]);\n  return FetchHttpClientResponse;\n}(HttpClient_js_1.HttpClientResponse);\nexports.FetchHttpClientResponse = FetchHttpClientResponse;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_classCallCheck","_createClass","_inherits","_createSuper","Object","defineProperty","exports","value","FetchHttpClientResponse","FetchHttpClient","HttpClient_js_1","_HttpClient_js_1$Http","_super","fetchFn","_this","call","_fetchFn","key","getClientName","makeRequest","host","port","path","method","headers","requestData","protocol","timeout","isInsecureConnection","url","URL","concat","methodHasPayload","body","undefined","fetch","fetchPromise","toString","pendingTimeoutId","timeoutPromise","Promise","_","reject","setTimeout","HttpClient","makeTimeoutError","race","then","res","finally","clearTimeout","_HttpClient_js_1$Http2","_super2","_this2","status","_transformHeadersToObject","_res","getRawResponse","toStream","streamCompleteCallback","toJSON","json","headersObj","_iterator","_step","s","n","done","entry","Array","isArray","length","Error","err","e","f","HttpClientResponse"],"sources":["C:/Users/Smert/OneDrive/Masaüstü/react_shop/client/node_modules/stripe/cjs/net/FetchHttpClient.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchHttpClientResponse = exports.FetchHttpClient = void 0;\nconst HttpClient_js_1 = require(\"./HttpClient.js\");\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nclass FetchHttpClient extends HttpClient_js_1.HttpClient {\n    constructor(fetchFn) {\n        super();\n        this._fetchFn = fetchFn;\n    }\n    /** @override. */\n    getClientName() {\n        return 'fetch';\n    }\n    makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n        const isInsecureConnection = protocol === 'http';\n        const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);\n        url.port = port;\n        // For methods which expect payloads, we should always pass a body value\n        // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n        // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n        // for more details.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        const body = requestData || (methodHasPayload ? '' : undefined);\n        const fetchFn = this._fetchFn || fetch;\n        const fetchPromise = fetchFn(url.toString(), {\n            method,\n            // @ts-ignore\n            headers,\n            // @ts-ignore\n            body,\n        });\n        // The Fetch API does not support passing in a timeout natively, so a\n        // timeout promise is constructed to race against the fetch and preempt the\n        // request, simulating a timeout.\n        //\n        // This timeout behavior differs from Node:\n        // - Fetch uses a single timeout for the entire length of the request.\n        // - Node is more fine-grained and resets the timeout after each stage of\n        //   the request.\n        //\n        // As an example, if the timeout is set to 30s and the connection takes 20s\n        // to be established followed by 20s for the body, Fetch would timeout but\n        // Node would not. The more fine-grained timeout cannot be implemented with\n        // fetch.\n        let pendingTimeoutId;\n        const timeoutPromise = new Promise((_, reject) => {\n            pendingTimeoutId = setTimeout(() => {\n                pendingTimeoutId = null;\n                reject(HttpClient_js_1.HttpClient.makeTimeoutError());\n            }, timeout);\n        });\n        return Promise.race([fetchPromise, timeoutPromise])\n            .then((res) => {\n            return new FetchHttpClientResponse(res);\n        })\n            .finally(() => {\n            if (pendingTimeoutId) {\n                clearTimeout(pendingTimeoutId);\n            }\n        });\n    }\n}\nexports.FetchHttpClient = FetchHttpClient;\nclass FetchHttpClientResponse extends HttpClient_js_1.HttpClientResponse {\n    constructor(res) {\n        super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n        this._res = res;\n    }\n    getRawResponse() {\n        return this._res;\n    }\n    toStream(streamCompleteCallback) {\n        // Unfortunately `fetch` does not have event handlers for when the stream is\n        // completely read. We therefore invoke the streamCompleteCallback right\n        // away. This callback emits a response event with metadata and completes\n        // metrics, so it's ok to do this without waiting for the stream to be\n        // completely read.\n        streamCompleteCallback();\n        // Fetch's `body` property is expected to be a readable stream of the body.\n        return this._res.body;\n    }\n    toJSON() {\n        return this._res.json();\n    }\n    static _transformHeadersToObject(headers) {\n        // Fetch uses a Headers instance so this must be converted to a barebones\n        // JS object to meet the HttpClient interface.\n        const headersObj = {};\n        for (const entry of headers) {\n            if (!Array.isArray(entry) || entry.length != 2) {\n                throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n            }\n            headersObj[entry[0]] = entry[1];\n        }\n        return headersObj;\n    }\n}\nexports.FetchHttpClientResponse = FetchHttpClientResponse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}