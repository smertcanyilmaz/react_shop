{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _inherits = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Smert/OneDrive/Masa\\xFCst\\xFC/react_shop/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeAutoPaginationMethods = void 0;\nvar utils_js_1 = require(\"./utils.js\");\nvar StripeIterator = /*#__PURE__*/function () {\n  function StripeIterator(firstPagePromise, requestArgs, spec, stripeResource) {\n    _classCallCheck(this, StripeIterator);\n    this.index = 0;\n    this.pagePromise = firstPagePromise;\n    this.promiseCache = {\n      currentPromise: null\n    };\n    this.requestArgs = requestArgs;\n    this.spec = spec;\n    this.stripeResource = stripeResource;\n  }\n  _createClass(StripeIterator, [{\n    key: \"iterate\",\n    value: function () {\n      var _iterate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(pageResult) {\n        var reverseIteration, idx, value, nextPageResult;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (pageResult && pageResult.data && typeof pageResult.data.length === 'number') {\n                _context.next = 2;\n                break;\n              }\n              throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n            case 2:\n              reverseIteration = isReverseIteration(this.requestArgs);\n              if (!(this.index < pageResult.data.length)) {\n                _context.next = 10;\n                break;\n              }\n              idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;\n              value = pageResult.data[idx];\n              this.index += 1;\n              return _context.abrupt(\"return\", {\n                value: value,\n                done: false\n              });\n            case 10:\n              if (!pageResult.has_more) {\n                _context.next = 17;\n                break;\n              }\n              // Reset counter, request next page, and recurse.\n              this.index = 0;\n              this.pagePromise = this.getNextPage(pageResult);\n              _context.next = 15;\n              return this.pagePromise;\n            case 15:\n              nextPageResult = _context.sent;\n              return _context.abrupt(\"return\", this.iterate(nextPageResult));\n            case 17:\n              return _context.abrupt(\"return\", {\n                done: true,\n                value: undefined\n              });\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function iterate(_x) {\n        return _iterate.apply(this, arguments);\n      }\n      return iterate;\n    }() /** @abstract */\n  }, {\n    key: \"getNextPage\",\n    value: function getNextPage(_pageResult) {\n      throw new Error('Unimplemented');\n    }\n  }, {\n    key: \"_next\",\n    value: function () {\n      var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.t0 = this;\n              _context2.next = 3;\n              return this.pagePromise;\n            case 3:\n              _context2.t1 = _context2.sent;\n              return _context2.abrupt(\"return\", _context2.t0.iterate.call(_context2.t0, _context2.t1));\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _next() {\n        return _next2.apply(this, arguments);\n      }\n      return _next;\n    }()\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this = this;\n      /**\n       * If a user calls `.next()` multiple times in parallel,\n       * return the same result until something has resolved\n       * to prevent page-turning race conditions.\n       */\n      if (this.promiseCache.currentPromise) {\n        return this.promiseCache.currentPromise;\n      }\n      var nextPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var ret;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _this._next();\n            case 2:\n              ret = _context3.sent;\n              _this.promiseCache.currentPromise = null;\n              return _context3.abrupt(\"return\", ret);\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }))();\n      this.promiseCache.currentPromise = nextPromise;\n      return nextPromise;\n    }\n  }]);\n  return StripeIterator;\n}();\nvar ListIterator = /*#__PURE__*/function (_StripeIterator) {\n  _inherits(ListIterator, _StripeIterator);\n  var _super = _createSuper(ListIterator);\n  function ListIterator() {\n    _classCallCheck(this, ListIterator);\n    return _super.apply(this, arguments);\n  }\n  _createClass(ListIterator, [{\n    key: \"getNextPage\",\n    value: function getNextPage(pageResult) {\n      var reverseIteration = isReverseIteration(this.requestArgs);\n      var lastId = getLastId(pageResult, reverseIteration);\n      return this.stripeResource._makeRequest(this.requestArgs, this.spec, _defineProperty({}, reverseIteration ? 'ending_before' : 'starting_after', lastId));\n    }\n  }]);\n  return ListIterator;\n}(StripeIterator);\nvar SearchIterator = /*#__PURE__*/function (_StripeIterator2) {\n  _inherits(SearchIterator, _StripeIterator2);\n  var _super2 = _createSuper(SearchIterator);\n  function SearchIterator() {\n    _classCallCheck(this, SearchIterator);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(SearchIterator, [{\n    key: \"getNextPage\",\n    value: function getNextPage(pageResult) {\n      if (!pageResult.next_page) {\n        throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n      }\n      return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n        page: pageResult.next_page\n      });\n    }\n  }]);\n  return SearchIterator;\n}(StripeIterator);\nvar makeAutoPaginationMethods = function makeAutoPaginationMethods(stripeResource, requestArgs, spec, firstPagePromise) {\n  if (spec.methodType === 'search') {\n    return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  if (spec.methodType === 'list') {\n    return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  return null;\n};\nexports.makeAutoPaginationMethods = makeAutoPaginationMethods;\nvar makeAutoPaginationMethodsFromIterator = function makeAutoPaginationMethodsFromIterator(iterator) {\n  var autoPagingEach = makeAutoPagingEach(function () {\n    return iterator.next.apply(iterator, arguments);\n  });\n  var autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  var autoPaginationMethods = _defineProperty({\n    autoPagingEach: autoPagingEach,\n    autoPagingToArray: autoPagingToArray,\n    // Async iterator functions:\n    next: function next() {\n      return iterator.next();\n    },\n    return: function _return() {\n      // This is required for `break`.\n      return {};\n    }\n  }, getAsyncIteratorSymbol(), function () {\n    return autoPaginationMethods;\n  });\n  return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return null;\n  }\n  var onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(\"The second argument to autoPagingEach, if present, must be a callback function; received \".concat(typeof onDone));\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  var onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(\"The first argument to autoPagingEach, if present, must be a callback function; received \".concat(typeof onItem));\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(\"The `onItem` callback function passed to autoPagingEach must accept at most two arguments; got \".concat(onItem));\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    var shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  var lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  var lastItem = listResult.data[lastIdx];\n  var lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach( /* onItem?, onDone? */\n  ) {\n    var args = [].slice.call(arguments);\n    var onItem = getItemCallback(args);\n    var onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(\"autoPagingEach takes up to two arguments; received \".concat(args));\n    }\n    var autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,\n    // @ts-ignore we might need a null check\n    onItem);\n    return (0, utils_js_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    var limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    var promise = new Promise(function (resolve, reject) {\n      var items = [];\n      autoPagingEach(function (item) {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(function () {\n        resolve(items);\n      }).catch(reject);\n    });\n    // @ts-ignore\n    return (0, utils_js_1.callbackifyPromiseWithTimeout)(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise(function (resolve, reject) {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      var item = iterResult.value;\n      return new Promise(function (next) {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(function (shouldContinue) {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true,\n            value: undefined\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  var args = [].slice.call(requestArgs);\n  var dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n  return !!dataFromArgs.ending_before;\n}","map":{"version":3,"names":["_defineProperty","require","default","_inherits","_createSuper","_regeneratorRuntime","_asyncToGenerator","_classCallCheck","_createClass","Object","defineProperty","exports","value","makeAutoPaginationMethods","utils_js_1","StripeIterator","firstPagePromise","requestArgs","spec","stripeResource","index","pagePromise","promiseCache","currentPromise","key","_iterate","mark","_callee","pageResult","reverseIteration","idx","nextPageResult","wrap","_callee$","_context","prev","next","data","length","Error","isReverseIteration","abrupt","done","has_more","getNextPage","sent","iterate","undefined","stop","_x","apply","arguments","_pageResult","_next2","_callee2","_callee2$","_context2","t0","t1","call","_next","_this","nextPromise","_callee3","ret","_callee3$","_context3","ListIterator","_StripeIterator","_super","lastId","getLastId","_makeRequest","SearchIterator","_StripeIterator2","_super2","next_page","page","methodType","makeAutoPaginationMethodsFromIterator","iterator","autoPagingEach","makeAutoPagingEach","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","return","_return","getAsyncIteratorSymbol","Symbol","asyncIterator","getDoneCallback","args","onDone","concat","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","asyncIteratorNext","slice","autoPagePromise","wrapAsyncIteratorWithCallback","callbackifyPromiseWithTimeout","opts","limit","promise","Promise","resolve","reject","items","push","then","catch","handleIteration","iterResult","dataFromArgs","getDataFromArgs","ending_before"],"sources":["C:/Users/Smert/OneDrive/Masaüstü/react_shop/client/node_modules/stripe/cjs/autoPagination.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeAutoPaginationMethods = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nclass StripeIterator {\n    constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n        this.index = 0;\n        this.pagePromise = firstPagePromise;\n        this.promiseCache = { currentPromise: null };\n        this.requestArgs = requestArgs;\n        this.spec = spec;\n        this.stripeResource = stripeResource;\n    }\n    async iterate(pageResult) {\n        if (!(pageResult &&\n            pageResult.data &&\n            typeof pageResult.data.length === 'number')) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n        }\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        if (this.index < pageResult.data.length) {\n            const idx = reverseIteration\n                ? pageResult.data.length - 1 - this.index\n                : this.index;\n            const value = pageResult.data[idx];\n            this.index += 1;\n            return { value, done: false };\n        }\n        else if (pageResult.has_more) {\n            // Reset counter, request next page, and recurse.\n            this.index = 0;\n            this.pagePromise = this.getNextPage(pageResult);\n            const nextPageResult = await this.pagePromise;\n            return this.iterate(nextPageResult);\n        }\n        return { done: true, value: undefined };\n    }\n    /** @abstract */\n    getNextPage(_pageResult) {\n        throw new Error('Unimplemented');\n    }\n    async _next() {\n        return this.iterate(await this.pagePromise);\n    }\n    next() {\n        /**\n         * If a user calls `.next()` multiple times in parallel,\n         * return the same result until something has resolved\n         * to prevent page-turning race conditions.\n         */\n        if (this.promiseCache.currentPromise) {\n            return this.promiseCache.currentPromise;\n        }\n        const nextPromise = (async () => {\n            const ret = await this._next();\n            this.promiseCache.currentPromise = null;\n            return ret;\n        })();\n        this.promiseCache.currentPromise = nextPromise;\n        return nextPromise;\n    }\n}\nclass ListIterator extends StripeIterator {\n    getNextPage(pageResult) {\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        const lastId = getLastId(pageResult, reverseIteration);\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n        });\n    }\n}\nclass SearchIterator extends StripeIterator {\n    getNextPage(pageResult) {\n        if (!pageResult.next_page) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n        }\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            page: pageResult.next_page,\n        });\n    }\n}\nconst makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n    if (spec.methodType === 'search') {\n        return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    if (spec.methodType === 'list') {\n        return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    return null;\n};\nexports.makeAutoPaginationMethods = makeAutoPaginationMethods;\nconst makeAutoPaginationMethodsFromIterator = (iterator) => {\n    const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));\n    const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n    const autoPaginationMethods = {\n        autoPagingEach,\n        autoPagingToArray,\n        // Async iterator functions:\n        next: () => iterator.next(),\n        return: () => {\n            // This is required for `break`.\n            return {};\n        },\n        [getAsyncIteratorSymbol()]: () => {\n            return autoPaginationMethods;\n        },\n    };\n    return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n        return Symbol.asyncIterator;\n    }\n    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n    return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n    if (args.length < 2) {\n        return null;\n    }\n    const onDone = args[1];\n    if (typeof onDone !== 'function') {\n        throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n    }\n    return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n    if (args.length === 0) {\n        return undefined;\n    }\n    const onItem = args[0];\n    if (typeof onItem !== 'function') {\n        throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n    }\n    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n    if (onItem.length === 2) {\n        return onItem;\n    }\n    if (onItem.length > 2) {\n        throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n    }\n    // This magically handles all three of these usecases (the latter two being functionally identical):\n    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n    return function _onItem(item, next) {\n        const shouldContinue = onItem(item);\n        next(shouldContinue);\n    };\n}\nfunction getLastId(listResult, reverseIteration) {\n    const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n    const lastItem = listResult.data[lastIdx];\n    const lastId = lastItem && lastItem.id;\n    if (!lastId) {\n        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n    }\n    return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n    return function autoPagingEach( /* onItem?, onDone? */) {\n        const args = [].slice.call(arguments);\n        const onItem = getItemCallback(args);\n        const onDone = getDoneCallback(args);\n        if (args.length > 2) {\n            throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n        }\n        const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, \n        // @ts-ignore we might need a null check\n        onItem);\n        return (0, utils_js_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);\n    };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n    return function autoPagingToArray(opts, onDone) {\n        const limit = opts && opts.limit;\n        if (!limit) {\n            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n        }\n        if (limit > 10000) {\n            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n        }\n        const promise = new Promise((resolve, reject) => {\n            const items = [];\n            autoPagingEach((item) => {\n                items.push(item);\n                if (items.length >= limit) {\n                    return false;\n                }\n            })\n                .then(() => {\n                resolve(items);\n            })\n                .catch(reject);\n        });\n        // @ts-ignore\n        return (0, utils_js_1.callbackifyPromiseWithTimeout)(promise, onDone);\n    };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n    return new Promise((resolve, reject) => {\n        function handleIteration(iterResult) {\n            if (iterResult.done) {\n                resolve();\n                return;\n            }\n            const item = iterResult.value;\n            return new Promise((next) => {\n                // Bit confusing, perhaps; we pass a `resolve` fn\n                // to the user, so they can decide when and if to continue.\n                // They can return false, or a promise which resolves to false, to break.\n                onItem(item, next);\n            }).then((shouldContinue) => {\n                if (shouldContinue === false) {\n                    return handleIteration({ done: true, value: undefined });\n                }\n                else {\n                    return asyncIteratorNext().then(handleIteration);\n                }\n            });\n        }\n        asyncIteratorNext()\n            .then(handleIteration)\n            .catch(reject);\n    });\n}\nfunction isReverseIteration(requestArgs) {\n    const args = [].slice.call(requestArgs);\n    const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n    return !!dataFromArgs.ending_before;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}